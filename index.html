<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Floor-Locked Stager</title>
    <!-- moved inline styles to external stylesheet -->
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>

    <model-viewer id="room-stager" src="models/sofa-v1.glb" ar ar-modes="webxr" ar-placement="floor" ar-scale="fixed"
        ar-hit-test initial-placement="floor" interpolation-decay="200" camera-controls shadow-intensity="2"
        shadow-softness="0" environment-image="neutral">

        <button slot="ar-button" id="ar-button">âœ¨ VIEW IN YOUR ROOM</button>

        <button id="rescan-button" onclick="rescan()">ðŸ”„ RESCAN FLOOR</button>

        <div id="instructions">
            <p id="instruction-text">Scanning floor... move phone side-to-side.</p>
        </div>

        <div class="slider">
            <div class="slide" style="background-image: url('./images/sofa.jpg')"
                onclick="changeModel('models/sofa-v1.glb')"></div>
            <div class="slide" style="background-image: url('./images/table1.webp')"
                onclick="changeModel('models/study_table-v2.glb')"></div>
            <div class="slide" style="background-image: url('./images/bed1.jpg')"
                onclick="changeModel('models/single_bed-v1.glb')"></div>
            <div class="slide" style="background-image: url('./images/gamingchair.webp')"
                onclick="changeModel('models/gaming_chair-v1.glb')"></div>
        </div>

    </model-viewer>

    <script>
        const mv = document.querySelector("#room-stager");
        const instructions = document.querySelector("#instructions");
        const statusText = document.querySelector("#instruction-text");
        const rescanBtn = document.querySelector("#rescan-button");

        // Samples buffer (lightweight)
        let hitSamples = [];
        const MAX_SAMPLES = 300;
        const MIN_PLANE_SAMPLES = 8;
        const INLIER_THRESHOLD = 0.08; // 8 cm tolerance for inliers
        let lastPlane = null; // {a,b,c} for y = a*x + b*z + c
        let emaPos = null; // exponential moving average of raw hit positions
        const EMA_ALPHA = 0.25; // smoothing factor
        let inAR = false;

        function changeModel(path) {
            mv.src = path;
        }

        function pushSample(x, y, z) {
            hitSamples.push({ x, y, z });
            if (hitSamples.length > MAX_SAMPLES) hitSamples.shift();
        }

        // Solve 3x3 linear system by Gaussian elimination (small, fast)
        function solve3(A, b) {
            const M = [
                [A[0][0], A[0][1], A[0][2], b[0]],
                [A[1][0], A[1][1], A[1][2], b[1]],
                [A[2][0], A[2][1], A[2][2], b[2]]
            ];
            for (let i = 0; i < 3; i++) {
                // pivot
                let maxRow = i;
                for (let r = i + 1; r < 3; r++) if (Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
                if (Math.abs(M[maxRow][i]) < 1e-12) return null; // singular
                if (maxRow !== i) { const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp; }
                // normalize
                const pivot = M[i][i];
                for (let c = i; c < 4; c++) M[i][c] /= pivot;
                // eliminate
                for (let r = 0; r < 3; r++) {
                    if (r === i) continue;
                    const factor = M[r][i];
                    for (let c = i; c < 4; c++) M[r][c] -= factor * M[i][c];
                }
            }
            return [M[0][3], M[1][3], M[2][3]];
        }

        // Fit plane y = a*x + b*z + c with least squares
        function fitPlane(samples) {
            if (!samples || samples.length < 3) return null;
            let Sxx = 0, Sxz = 0, Sx = 0, Szz = 0, Sz = 0, Sxy = 0, Szy = 0, Sy = 0;
            const N = samples.length;
            for (const p of samples) {
                const x = p.x, z = p.z, y = p.y;
                Sxx += x * x;
                Sxz += x * z;
                Sx += x;
                Szz += z * z;
                Sz += z;
                Sxy += x * y;
                Szy += z * y;
                Sy += y;
            }
            const A = [
                [Sxx, Sxz, Sx],
                [Sxz, Szz, Sz],
                [Sx, Sz, N]
            ];
            const B = [Sxy, Szy, Sy];
            const sol = solve3(A, B);
            if (!sol) return null;
            const [a, b, c] = sol;
            return { a, b, c };
        }

        function projectYOnPlane(x, z, plane) {
            return plane.a * x + plane.b * z + plane.c;
        }

        // Robust one-pass inlier selection + refit
        function robustFit(samples) {
            if (samples.length < MIN_PLANE_SAMPLES) return null;
            let plane = fitPlane(samples);
            if (!plane) return null;
            // compute inliers
            const inliers = samples.filter(s => Math.abs(projectYOnPlane(s.x, s.z, plane) - s.y) <= INLIER_THRESHOLD);
            if (inliers.length < Math.max(6, Math.floor(0.5 * samples.length))) {
                // Not enough inliers yet
                return null;
            }
            // refit with inliers
            const refined = fitPlane(inliers) || plane;
            return { plane: refined, inliers };
        }

        // Handle various hit-test detail shapes and add sample
        function handleHitTestEvent(detail) {
            if (!detail) return;
            let x, y, z;
            if (detail.position && typeof detail.position.x === 'number') {
                x = detail.position.x; y = detail.position.y; z = detail.position.z;
            } else if (detail.hitMatrix && detail.hitMatrix.length >= 3) {
                const m = detail.hitMatrix;
                x = m[12] ?? m[3] ?? 0;
                y = m[13] ?? m[7] ?? 0;
                z = m[14] ?? m[11] ?? 0;
            } else if (detail.transform && detail.transform.position) {
                x = detail.transform.position.x; y = detail.transform.position.y; z = detail.transform.position.z;
            } else {
                return;
            }
            pushSample(x, y, z);
            // update EMA for smoother placement anchor
            if (!emaPos) emaPos = { x, y, z };
            else {
                emaPos.x = emaPos.x * (1 - EMA_ALPHA) + x * EMA_ALPHA;
                emaPos.y = emaPos.y * (1 - EMA_ALPHA) + y * EMA_ALPHA;
                emaPos.z = emaPos.z * (1 - EMA_ALPHA) + z * EMA_ALPHA;
            }

            // attempt robust plane fit when sufficient samples
            const fit = robustFit(hitSamples);
            if (fit && fit.plane) {
                lastPlane = fit.plane;
                statusText.innerText = "Floor locked. Tap to place.";
                statusText.style.background = "rgba(0, 128, 0, 0.8)";
                setTimeout(() => instructions.style.display = "none", 1200);
            } else {
                lastPlane = null;
                statusText.innerText = "Scanning floor... move phone side-to-side.";
                statusText.style.background = "rgba(0, 0, 0, 0.75)";
                instructions.style.display = "block";
            }
        }

        // Tap to place: project EMA position onto the fitted plane for accurate snap
        mv.addEventListener('click', (ev) => {
            if (!inAR) return;
            if (!lastPlane || !emaPos) {
                showTransientNote("No valid floor plane yet. Move phone to scan more area.");
                return;
            }
            const targetX = emaPos.x;
            const targetZ = emaPos.z;
            const targetY = projectYOnPlane(targetX, targetZ, lastPlane);
            const root = getModelRoot();
            if (root) {
                if ('position' in root) {
                    root.position.x = targetX;
                    root.position.y = targetY;
                    root.position.z = targetZ;
                    showTransientNote("Placed on detected floor plane.");
                } else if ('translation' in root) {
                    root.translation.x = targetX;
                    root.translation.y = targetY;
                    root.translation.z = targetZ;
                    showTransientNote("Placed on detected floor plane.");
                } else {
                    showTransientNote("Placement not supported in this runtime.");
                }
            } else {
                showTransientNote("Placement not available in this browser/AR runtime.");
            }
        });

        // Hook hit-test events
        mv.addEventListener('ar-hit-test', (e) => handleHitTestEvent(e.detail));
        mv.addEventListener('ar-hit-test-achieved', (e) => {
            if (e.detail) handleHitTestEvent(e.detail);
            // the status text handling is in handleHitTestEvent
        });

        // AR session state
        mv.addEventListener('ar-status', (event) => {
            if (event.detail.status === 'session-started') {
                instructions.style.display = "block";
                rescanBtn.style.display = "block";
                inAR = true;
            } else {
                instructions.style.display = "none";
                rescanBtn.style.display = "none";
                inAR = false;
            }
        });

        // Get model root helper (best-effort; unchanged)
        function getModelRoot() {
            try {
                if (mv.model && mv.model.scene) return mv.model.scene;
                if (mv.getModel && mv.getModel()) {
                    const m = mv.getModel();
                    if (m.scene) return m.scene;
                    if (m.scenes && m.scenes[0]) return m.scenes[0];
                }
                if (mv._scene && mv._scene.root) return mv._scene.root;
            } catch (e) { }
            return null;
        }

        // Transient small user notes
        let noteTimeout = null;
        function showTransientNote(msg) {
            // reuse instruction area to keep UI minimal
            statusText.innerText = msg;
            clearTimeout(noteTimeout);
            noteTimeout = setTimeout(() => {
                statusText.innerText = lastPlane ? "Floor locked. Tap to place." : "Scanning floor... move phone side-to-side.";
            }, 1800);
        }

        // Rescan: clear samples and plane state
        function rescan() {
            const currentSrc = mv.src;
            mv.src = ""; // Clear momentarily to force internal reset
            hitSamples = [];
            lastPlane = null;
            emaPos = null;
            setTimeout(() => {
                mv.src = currentSrc;
                instructions.style.display = "block";
                statusText.innerText = "Rescanning... find a flat surface.";
                statusText.style.background = "rgba(0, 0, 0, 0.75)";
                showTransientNote("Rescanning floor. Move phone slowly to map the area.");
            }, 150);
        }

        window.rescan = rescan;

        // initial status
        statusText.innerText = "Scanning floor... move phone side-to-side.";
        statusText.style.background = "rgba(0, 0, 0, 0.75)";

    </script>
</body>

</html>